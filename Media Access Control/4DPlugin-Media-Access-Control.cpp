/* --------------------------------------------------------------------------------
 #
 #  4DPlugin-Media-Access-Control.cppF
 #	source generated by 4D Plugin Wizard
 #	Project : Media Access Control
 #	author : miyako
 #	2019/12/13
 #  
 # --------------------------------------------------------------------------------*/

#include "4DPlugin-Media-Access-Control.h"

#pragma mark -

void PluginMain(PA_long32 selector, PA_PluginParameters params) {
    
	try
	{
        switch(selector)
        {
			// --- Media Access Control
            
			case 1 :
				Get_hardware_address(params);
				break;

        }

	}
	catch(...)
	{

	}
}

#pragma mark -

void Get_hardware_address(PA_PluginParameters params) {

    sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
    PackagePtr pParams = (PackagePtr)params->fParameters;
    
    
        ARRAY_TEXT Param1;
        ARRAY_TEXT Param2;
        ARRAY_TEXT Param3;
        ARRAY_TEXT Param4;
        C_TEXT returnValue;
        
        Param1.setSize(1);
        Param2.setSize(1);
        Param3.setSize(1);
        Param4.setSize(1);
        
    #if VERSIONMAC
        NSArray * interfaces = (NSArray *)SCNetworkInterfaceCopyAll();
        
        if(interfaces)
        {
            for(unsigned int i = 0; i < [interfaces count]; ++i)
            {
                SCNetworkInterfaceRef interface = (SCNetworkInterfaceRef)[interfaces objectAtIndex:i];
                
                if(interface)
                {
                    NSString *hardwareAddress = (NSString *)SCNetworkInterfaceGetHardwareAddressString(interface);
                    NSString *name = (NSString *)SCNetworkInterfaceGetBSDName(interface);
                    NSString *interfaceType = (NSString *)SCNetworkInterfaceGetInterfaceType(interface);
                    NSString *displayName = (NSString *)SCNetworkInterfaceGetLocalizedDisplayName(interface);
                    
                    if(!hardwareAddress) hardwareAddress = @"";
                    if(!hardwareAddress) name = @"";
                    if(!hardwareAddress) interfaceType = @"";
                    if(!hardwareAddress) displayName = @"";
                    
                    Param1.appendUTF16String(hardwareAddress);
                    Param2.appendUTF16String(interfaceType);
                    Param3.appendUTF16String(name);
                    Param4.appendUTF16String(displayName);
                    
                    if ([name isEqualToString:@"en0"])
                        returnValue.setUTF16String(hardwareAddress);
                }
            }
            
            [interfaces release];
        }
    #else
        
        PIP_ADAPTER_ADDRESSES pAddresses = NULL;
        
        ULONG bufferSize = 30000;
        
        //Note that the length of the IP_ADAPTER_ADDRESSES structure changed on Windows XP with SP1 and later and also on Windows Vista and later.
        //http://msdn.microsoft.com/en-us/library/windows/desktop/aa366058(v=vs.85).aspx
        //The method of using the GetAdaptersAddresses function is strongly discouraged.
        //This method requires calling the GetAdaptersAddresses function multiple times.
        //http://msdn.microsoft.com/en-us/library/aa365915(v=vs.85).aspx
        //The recommended method of calling the GetAdaptersAddresses function is
        //to pre-allocate a 15KB working buffer pointed to by the AdapterAddresses parameter.
        
        std::vector<uint8_t> buf(bufferSize);
        pAddresses = (IP_ADAPTER_ADDRESSES *)&buf[0];
        
        DWORD dwRetVal = GetAdaptersAddresses(AF_UNSPEC,    //Return both IPv4 and IPv6 addresses associated with adapters with IPv4 or IPv6 enabled.
                                                                                    GAA_FLAG_INCLUDE_PREFIX,    //Return a list of IP address prefixes on this adapter. When this flag is set, IP address prefixes are returned for both IPv6 and IPv4 addresses. This flag is supported on Windows XP with SP1 and later.
                                                                                    NULL,
                                                                                    pAddresses,
                                                                                    &bufferSize);
        
        if(dwRetVal == ERROR_SUCCESS)
        {
            PIP_ADAPTER_ADDRESSES pCurrAddresses = pAddresses;
            
            while(pCurrAddresses)
            {
                CUTF8String interfaceType;
                
                CUTF16String description;
                CUTF16String friendlyName;
                CUTF8String physicalAddress;
                
                switch(pCurrAddresses->IfType)
                {
                    case IF_TYPE_OTHER:
                        interfaceType = (const uint8_t *)"Other";
                        break;
                    case IF_TYPE_ETHERNET_CSMACD:
                        interfaceType = (const uint8_t *)"Ethernet";
                        break;
                    case IF_TYPE_ISO88025_TOKENRING:
                        interfaceType = (const uint8_t *)"Token-Ring";
                        break;
                    case IF_TYPE_PPP:
                        interfaceType = (const uint8_t *)"PPP";
                        break;
                    case IF_TYPE_SOFTWARE_LOOPBACK:
                        interfaceType = (const uint8_t *)"Software-Loopback";
                        break;
                    case IF_TYPE_ATM:
                        interfaceType = (const uint8_t *)"ATM";
                        break;
                    case IF_TYPE_IEEE80211:
                        interfaceType = (const uint8_t *)"IEEE80211";
                        break;
                    case IF_TYPE_TUNNEL:
                        interfaceType = (const uint8_t *)"Tunnel";
                        break;
                    case IF_TYPE_IEEE1394:
                        interfaceType = (const uint8_t *)"IEEE1394";
                        break;
                }
                
                description = (const PA_Unichar *)pCurrAddresses->Description;
                friendlyName = (const PA_Unichar *)pCurrAddresses->FriendlyName;
                
                DWORD physicalAddressLength = pCurrAddresses->PhysicalAddressLength;
                
                if(physicalAddressLength == 6)
                {
                    char macAddress[512];
                    
                    sprintf_s(macAddress,
                                        sizeof(macAddress),
                                        "%02x:%02x:%02x:%02x:%02x:%02x",
                                        pCurrAddresses->PhysicalAddress[0],
                                        pCurrAddresses->PhysicalAddress[1],
                                        pCurrAddresses->PhysicalAddress[2],
                                        pCurrAddresses->PhysicalAddress[3],
                                        pCurrAddresses->PhysicalAddress[4],
                                        pCurrAddresses->PhysicalAddress[5]);
                    
                    physicalAddress = CUTF8String((const uint8_t *)macAddress, 17);
                    
                    if((pCurrAddresses->IfType == IF_TYPE_ETHERNET_CSMACD)
                         && (description.find((const PA_Unichar *)L"Bluetooth" ) == CUTF16String::npos))
                    {
                        returnValue.setUTF8String(&physicalAddress);
                    }
                    
                }
                
                Param1.appendUTF8String(&physicalAddress);
                Param2.appendUTF8String(&interfaceType);
                Param3.appendUTF16String(&description);
                Param4.appendUTF16String(&friendlyName);
                
                pCurrAddresses = pCurrAddresses->Next;
            }
        }
        
    #endif
        
        Param1.toParamAtIndex(pParams, 1);
        Param2.toParamAtIndex(pParams, 2);
        Param3.toParamAtIndex(pParams, 3);
        Param4.toParamAtIndex(pParams, 4);
        returnValue.setReturn(pResult);

}

